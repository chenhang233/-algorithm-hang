#                             				x86汇编

## 1. 基本概念

#### 1.1 为什么学?

```
	汇编可以精细化控制机器码.
	学习汇编对计算机硬件、操作系统和应用程序之间的交互有更全面，更底层的理解.
```

#### 1.2 虚拟机概念

```
	操作计算机硬件的软件,从底层的数字逻辑(分层L0)到指令架构集(机器语言 L1)到汇编(分层L2)再到高级语言(L3). 每一层都是封装,都是对下一层的描述,虚拟机的概念就是抽象封装出来的上层架构.
```

#### 1.3 数据表示

##### 1.3.1  二进制整数 

```visual basic
	二进制用2个数字作为基础,0和1.位从右往左，左边位称为最高有效位(Most Significant Bit MSB),右边位称为最低有效位(least significant bit LSB)
	二进制整数分为有符号和无符号,有符号分为正数和负数,无符号默认是正数.
```

##### 1.3.2  二进制加法

```visual basic
	从低位到高位,按位加.
```

##### 1.3.3 整数存储大小

```visual basic
	x86中,数据基本存储单位是字节(byte),一字节有8位.
	字(2 byte) 双字(4 byte) 四字(8 byte) 八字(16 byte)
```

##### 13.6 有符号二进制整数

```visual basic
	在x86中MSB表示符号位,0正数,1负数.负数用补码表示(原码取反得到反码,反码加一得到补码  补码取反加一得到原码)
	有符号二进制转十进制:
	如果最高位是1,说明存的是补码,补码取反加一得到原码.按无符号整数进行求十进制.如果最高位是0,直接求十进制.
	例:  有符号   1111 0000  (-16)
		  取反   0000 1111
		  加一   0001 0000
		  转换   16
		  结果   -16
```

##### 1.3.8 字符存储

```visual basic
	计算机使用字符集,主流 unicode标准  UTF-8(把Unicode编码转化为“可变长编码”的UTF-8编码) ASCII
	unicode和ascii的区别:
		1、ASCII编码是1个字节，而Unicode编码通常是2个字节。
		2、ASCII是单字节编码，无法用来表示中文；而Unicode可以表示所有语言。
		3、用Unicode编码比ASCII编码需要多一倍的存储空间。
```

#### 1.4 布尔表达式

```
	布尔代数l定义一组操作 值为真(true)假(false)
		非 NOT !
		或 OR  ||
		与 AND &&
```

## 2.x86处理器架构

#### 1.基础设计

```jsx
	中央处理器CPU 进行算术和逻辑操作
	包含有限数量的存储位置: 
		寄存器(register) 寄存器是CPU内部用来存放数据的一些小型存储区域，用来暂时存放参与运算的数据和运算结果
        高频时钟(clock) 对cpu内部操作与系统其他组件同步
        控制单元(CU control unit) 控制机器指令步骤顺序
        算术逻辑单元(ALU arithmetic logic unit) 执行算术(加减)和逻辑(与或非)
	CPU通过主板的CPU插座引脚和其他部分相连.引脚连接数据总线、控制总线、地址总线.
	
	内存单元(memory storage unit) 用于程序运行时保存数据和指令,和cpu交互传输(把程序复制到cpu,从cpu复制到内存).
	
	总线(bus) 一组并行线,将数据从计算机一个部分传到另一个部分,总线分为四类.
		数据总线(data bus) 在CPU和内存之间传输数据和指令.
		I/O总线(input/output bus) 在CPU和系统输入/输出设备之间传输数据.
		控制总线(control bus) 用二进制信号对连接在系统总线上的设备同步.
		地址总线(address bus) 指令在CPU和内存之间传输数据时,地址总线保持指令和数据的地址.
	为什么从内存读数据比从寄存器读慢?
		内存读步骤:
			1.将想读的值地址放到地址总线.
			2.设置处理器读取引脚.
			3.等待一个时钟周期给存储芯片反应.
			4.将数据从数据总线复制到目标.
		大概需要4个时钟周期,从寄存器取只需要1个时钟周期.
		
    加载执行
    	需要程序加载器将程序加载到内存.加载后,操作系统将CPU指向程序入口.
```

#### 2.  32位x86处理器

##### 2.1 x86处理器操作模式:

```

		保护模式(protected mode) 处理器的原生状态,所有指令和特性可用.分配给程序的独立内存空间称为段,处理器会阻止程序访问自身段之外的内存.
		虚拟8086模式(virtual- 8086 mode) 虚拟8086模式是为了在保护模式下兼容8086程序而设置的,实际上这是一种实模式与保护模式的混合.
		实地址模式(real address mode) 早期intel处理器编程环境,可以切换到其他模式.当程序需要直接访问系统内存和硬件使用.
		系统管理模式(system management mode) 向操作系统提供电源管理和系统安全机制.这些功能由制造商提供.
	
	执行环境:
		1.地址空间
			在32位保护模式下,一个程序最大寻址空间是4GB.使用扩展物理寻址(extended physical addressing)可以使被寻址空间增加到64GB. 实地址模式只能寻址1MB,如果在保护模式下运行多个虚拟8086,每个程序只能拥有自己的1MB.
		
```

##### 2.2 执行寄存器 

```
	通用寄存器 用于算术运算和数据传输.
		EAX 扩展累加寄存器(extended accumulator) 乘除默认使用
		ECX 为循环计数器 CPU 默认使用
		ESP 扩展堆栈指针寄存器(extended stack pointer) 用于寻址堆栈
		ESI 扩展源变址寄存器(extended source index) EDI 扩展目的寄存器(extended destination index) 用于高速存储器传输指令 
```

| 32位 | 16位 | 8位(高) | 8位(低) |
| :--: | :--: | :-----: | :-----: |
| EAX  |  AX  |   AH    |   AL    |
| EBX  |  BX  |   BH    |   BL    |
| ECX  |  CX  |   CH    |   CL    |
| EDX  |  DX  |   DH    |   DL    |

| 32位 | 16位 |
| :--: | :--: |
| ESI  |  SI  |
| EDI  |  DI  |
| EBP  |  BP  |
| ESP  |  SP  |



```
	段寄存器 
		实地址模式中, 16位段寄存器表示预先分配的内存区域的基址,这个区域称为段.保护模式中,段寄存器存放段描述符表指针.一些段存放指令,其他段存放数据,还有一个堆栈段存放局部函数变量和函数参数.
	指令指针寄存器  
		EIP 存下一条要执行的指令地址.可以控制EIP,使程序分支转到一个新位置.
	EFLAGS (或者Flags) 寄存器 
		包含独立二进制位,控制CPU操作,或者反应CPU操作结果.设置标志位 =1 清除 =0 .
		控制标志位
    		控制CPU操作,使CPU进入中断,侦测到算术溢出时中断执行.进入虚拟8086模式,保护模式.
    	状态标志位
 			反应CPU执行的算术和逻辑操作结果.(溢出位 OF、符号位 SF、零标志位 ZF、辅助进位标志位 AC、奇偶标志位 PF、进位标志位 CF)
```

##### 2.3 MMX寄存器

```
	8个64位MMX寄存器称为SIMD流扩展指令.
```

##### 2.4 XMM寄存器

```
	x86包括8个128位XMM寄存器,用于流扩展指令集.
	浮点单元(FPU floating-poin unit)执行浮点运算.
```



#### 3. 64位 x86-64 处理器

##### 3.1 特征

- 向后兼容x86指令集 	
- 地址长度64位,虚拟地址空间2的64次方字节
-  可以使用64位通用寄存器
-  比x86多8个通用寄存器
- 物理地址48位,支持256TB RAM

##### 3.2 64位操作模式

```
	1.兼容模式
		兼容32位16位程序
	2.64位模式
		使用64位线性地址空间的应用程序.
```

##### 3.3 通用寄存器

```
	64位默认操作32位. 指令加上REX(寄存器扩展)前缀后,操作数达到64位.
```

| 操作数大小 |                          可用寄存器                          |
| :--------: | :----------------------------------------------------------: |
|    8位     | AL BL CL DL DIL SIL BPL SPL R8L R9L R10L R11L R12L R13L R14L R15L |
|    16位    | AX BX CX DX DI SI BP SP R8W R9W R10W R11W R12W R13W R14W R15W |
|    32位    | EAX EBX ECX EDX EDI ESI EBP ESP R8D R9D R10D R11D R12D R13D R14D R15D |
|    64位    |  RAX RDX RCX RDX RDI RSI RBP R8 R9 R10 R11 R12 R13 R14 R15   |

##### 3.4 X86计算机组件

```c
	微型计算机的心脏是主板,主板上有CPU、支持处理器、主存、输入和输出接口、电源接口和扩展插槽.
	PC中使用的基本存储器: ROM EPROM 动态RAM 静态RAM 视频RAM 和CMOS ROM.
	与虚拟机相似.输入和输出通过不同层次访问实现.库函数调操作系统,操作系统调BIOS(基本输入输出系统),BIOS与硬件设备通信.
	
	BIOS(Basic Input Output System)概念
		专门负责系统硬件各种参数设定，本质上是“程序”，也就是一组“代码”
```

#### 3.汇编语言基础

##### 1. 基本语言元素

```c
汇编程序

COMMENT #
	注释区
#
 
.386 ; 表示32位程序,能访问32位寄存器和地址
.model flat,stdcall ;程序内存模式(flat 保护模式) 子程序调用规范(stdcall)
.stack 4096 ; 为运行时堆栈保留4096字节空间
ExitProcess PROTO, dwExitCode: DWORD ;windows服务,调用   DWORD(32位无符号整数)

.data ;数据区
f1 DWORD 1;
f2 DWORD 2;
f3 DWORD 3;
sum DWORD 0 ;定义变量0

.code ;代码区
main PROC
 mov eax,f1;
 add eax,f2;
 add eax,f3;
 mov sum,eax;

 INVOKE ExitProcess,0
main ENDP ;标记一个过程结束
END main ;标记程序结束
```

```c
整数常量:
	26;十进制  26d;十进制  11010b;二进制  42q;八进制  42o;八进制  1Ah;十六进制 0A3h;十六进制 (字母开头十六进制加前缀0,防止汇编器解析为标识符)

浮点数常量:
	2.	+3.0	-44.2E+05	26.E5
 
字符串常量:
	"this is 'a' test"

指令:
 [标号:(可选)] 指令助记符 [操作数(通常必需)] [;注释(可选）)]
    标号: 指令和数据的标识位置,表示指令或变量的地址.(用做跳转和循环指令的目标)
         target:
			mov ax,bx
            jmp target
         L1: mov ax,bx
         L2:
	指令助记符: 标记一个指令的短单词
        mov 传送数值	add 两数相加	sub 从一个数中减去另一个数		mul 两数相乘	jmp 跳转到新位置		call 调用一个子程序

	操作数: 指令输入输出的数值(操作 内存数 寄存器 整数表达式 输入输出端口) 

NOP(空操作)指令: 占一个字节,无操作(代码对齐 x86 从双字的偶数倍地址处加载代码和数据,更快)       
	
	
```



##### 2.  汇编、链接和运行程序

###### 2.1. 执行周期

```
汇编源文件 -汇编器-> 目标文件(可能和列表文件) -链接器(复制被请求的链接库到目标文件)-> 可执行文件 -OS加载器(操作系统把程序加载到内存,使CPU分支到程序起始地址)-> 输出
列表文件: 程序源文件副本,数字地址,16进制机器代码
```



##### 3.  定义数据

######  3.1 数据定义语句

```
在内存中为变量留出存储空间,赋予名字
初始值: 可以用 ? 不对变量初始化
多初始值: 标号只指出第一个初始值的偏移量
	list BYTE 10,20,30    偏移: 0000,0001,0002
字符串: greeting BYTE "hello world",0
```

|  类型  |              用法               |
| :----: | :-----------------------------: |
|  BYTE  |     8位无符号整数.B代表字节     |
| SBYTE  |    8位有符号整数,S代表有符号    |
|  WORD  |         16位无符号整数          |
| SWORD  |         16位有符号整数          |
| DWORD  |    32位无符号整数,D代表双字     |
| SDWORD | 32位有符号整数,SD代表有符号双字 |
| FWORD  |    48位整数(保护模式远指针)     |
| QWORD  |        64位整数,Q代表4字        |
| TBYTE  |  80位(10字节)整数,T代表10字节   |
| REAL4  |      32位(4字节)IEEE短实数      |
| REAL8  |      64位(8字节)IEEE长实数      |
| REAL10 |    80位(10字节)IEEE扩展实数     |

###### 3.2 DUP操作符

```
使用一个整数表达式作为计数器,为多个数据项分配存储空间.可以初始化和非初始化
	BYTE 20 DUP(0) ;20字节,值都为0
	BYTE 20 DUP(?) ;20字节,非初始化
	BYTE 4 DUP("STACK") ;20字节

16位字数组 
	myList WORD 1,2,3,4,5 ;假设起始偏移0,地址增量 2个字节(1字)
使用DUP分配数组
	array WORD 5 DUP(?) ;5个数值,未初始化
```



##### 4.  符号常量



##### 5.  64位编程